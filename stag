#!/usr/bin/env python3

from fuse import FUSE, FuseOSError, Operations
import logging
import sqlite3
import click
import errno
import stat
import sys
import os


# configure logger and define the decorator
logging.basicConfig(
    level=logging.INFO,                                   # default logging level for this script
    format='[%(asctime)s] [%(levelname)s]\n%(message)s',  # message format
    handlers=[logging.StreamHandler()]
)

def log_call(func):
    def wrapper(self, *args, **kwargs):
        try:
            result = func(self, *args, **kwargs)
            logging.info(f"{func.__name__}, args={args}, kwargs={kwargs}\nreturned {result!r}\n")
            return result
        except Exception as e:
            logging.info(f"{func.__name__}, args={args}, kwargs={kwargs}\nraised {e.__class__.__name__}({errno.errorcode.get(e.errno, 'UNKNOWN')})\n")
            raise
    return wrapper


class StagFS(Operations):
    # ---------------------------------------------------------------------------------------------------------------
    # Auxiliary functions
    # ---------------------------------------------------------------------------------------------------------------

    def get_info(self, path, check_valid=False):
        """ Analyze path on virtual filesystem determine its type (root folder, file or tag) and validity.

        Args:
            path (str): The path in the virtual filesystem to analyze.
            check_valid (bool, optional): If True checks if the path is a valid file or tag path. Defaults to False.

        Returns:
            If check_valid is False, returns a tuple (is_root, is_file, is_tag):
                - is_root (bool): True if the path is the root directory.
                - is_file (bool): True if the path corresponds to a file.
                - is_tag (bool): True if the path corresponds to a tag (directory).
            If check_valid is True, returns a tuple (is_root, is_file, is_tag, is_valid):
                - is_valid (bool): True if the path is a valid file or tag path, False otherwise.
        """

        # split `path` to get the basename
        basename = path.split("/")[-1]

        # if we're dealing with the root directory
        if basename == "":
            is_root = True
            is_file = False
            is_tag  = False

            if check_valid:
                is_valid = True
                return is_root, is_file, is_tag, is_valid
            else:
                return is_root, is_file, is_tag

        # otherwise check if its either a file or a tag
        is_root = False
        is_file = os.path.isfile(f"{self.src}/{basename}")
        is_tag  = os.path.isdir(f"{self.src}/{basename}")

        # if its neither, it doesn't exist and we return here
        if (not is_file) and (not is_tag):
            if check_valid:
                is_valid = False
                return is_root, is_file, is_tag, is_valid
            else:
                return is_root, is_file, is_tag

        # if is a file
        # the file is valid if its path is a subset of its corresponding tags
        if is_file:
            if check_valid:
                res = self.cur.execute(f"SELECT tags FROM files WHERE path LIKE '{basename}'").fetchone()
                res_tags = [tag for tag in res[0].split("/") if tag]

                tags = path.split("/")[1:-1]

                is_valid = False
                if (set(tags) <= set(res_tags)):
                    is_valid = True

                return is_root, is_file, is_tag, is_valid
            else:
                return is_root, is_file, is_tag

        # if is a tag
        # the tag is valid if there is at least one file inside the provided path or is located in the root dir
        if is_tag:
            if check_valid:
                is_valid = False
                tags = path.split("/")[1:]

                if len(tags) == 1:
                    is_valid = True

                else:
                    query = "SELECT path, tags FROM files WHERE " + " AND ".join([f"tags LIKE '%/{tag}/%'" for tag in tags])
                    res = self.cur.execute(query).fetchone()
                    if res:
                        is_valid = True

                return is_root, is_file, is_tag, is_valid
            else:
                return is_root, is_file, is_tag

    # ---------------------------------------------------------------------------------------------------------------
    # Initialization and destruction
    # ---------------------------------------------------------------------------------------------------------------

    def __init__(self, src, db):
        """Called on object initialization.

        Args:
            src (str): Path to the directory containing the real files.
            db (str): Path to the SQLite database file.
        """

        self.src = src
        self.con = sqlite3.connect(db)
        self.cur = self.con.cursor()

    def __del__(self):
        """Called on object destruction.
        """

        self.con.close()

        pass

    def init(self, path):
        """Called on filesystem initialization.

        This function must be used instead of `__init__` if you start threads on initialization.

        Args:
            path (str): Is always `"/"`.
        """

        pass

    def destroy(self, path):
        """Called on filesystem destruction.

        Args:
            path (str): Is always `"/"`.
        """

        pass

    # ---------------------------------------------------------------------------------------------------------------
    # Filesystem methods
    # ---------------------------------------------------------------------------------------------------------------

    def access(self, path, mode):
        """ Check if a file or directory is accessible with the given mode.

        According to the manpage of the function `access`, the usage of this function is discouraged and may be formally deprecated in the future.

        Args:
            path (str): The path to the file or directory in the virtual filesystem.
            mode (int): The access mode to check (e.g., os.R_OK, os.W_OK, os.X_OK).
        """

        # TODO

        raise FuseOSError(errno.ENOSYS)

    def chmod(self, path, mode):
        """ Changes the permissions of path in the virtual filesystem.

        Args:
            path (str): The path to the file or folder.
            mode (int): The numeric value of the permissions.

        Raises:
            FuseOSError: If the path does not exist (errno.ENOENT).
        """

        is_root, is_file, is_tag, is_valid = get_info(path, check_valid=True)

        if is_valid:
            basename = path.split("/")[-1]
            os.chmod(self.src + "/".join([basename]), mode)
        else:
            raise FuseOSError(errno.ENOENT)

        pass

    def chown(self, path, uid, gid):
        """ Changes the owner of path in the virtual filesystem.

        Args:
            path (str): The path to the file or folder.
            uid (int): User ID.
            gid (int): Group ID.

        Raises:
            FuseOSError: If the path does not exist (errno.ENOENT).
        """

        is_root, is_file, is_tag, is_valid = get_info(path, check_valid=True)

        if is_valid:
            basename = path.split("/")[-1]
            os.chown(self.src + "/".join([basename]), uid, gid)
        else:
            raise FuseOSError(errno.ENOENT)

        pass

    def getattr(self, path, fh=None):
        """ Fetches the attributes of a file or folder in the virtual filesystem.

        Args:
            path (str): The path to the file or folder in the virtual filesystem.
            fh (int, optional): File handle (ignored). Defaults to None.

        Returns:
            dict: A dictionary with the attributes of the specified path, similar to the output of os.lstat().

        Raises:
            FuseOSError: If the path does not exist (errno.ENOENT).
        """

        # split `path` to get the basename
        basename = path.split("/")[-1]

        # if `path` is an empty string, it corresponds to the root directory of the mount dir
        # if this is the case, we fetch the attributes of the source dir
        if basename == "":
            st = os.lstat(self.src)
            at = dict((key, getattr(st, key)) for key in (
                'st_atime', 'st_ctime','st_gid', 'st_mode', 'st_mtime', 'st_nlink', 'st_size','st_uid','st_blocks'
            ))

        # if it's a tag
        # we need to check if `path` is valid, and this implies thatthere is at least one file with these tags
        elif os.path.isdir(self.src + "/" + basename):
            tags = path.split("/")[1:]

            # if there is only on tag in `tags`, its itself, and we can just check directly whether the folder exists
            if len(tags) == 1:
                try:
                    st = os.lstat(f"{self.src}/{basename}")
                    at = dict((key, getattr(st, key)) for key in (
                        'st_atime', 'st_ctime','st_gid', 'st_mode', 'st_mtime', 'st_nlink', 'st_size','st_uid','st_blocks'
                    ))
                except FileNotFoundError:
                    raise FuseOSError(errno.ENOENT)
                except Exception:
                    raise FuseOSError(errno.EINVAL)

            else:
                conditions = []
                for tag in tags:
                    conditions.append(f"tags LIKE '%/{tag}/%'")
                query = "SELECT path, tags FROM files WHERE " + " AND ".join(conditions)

                res = self.cur.execute(query).fetchone()

                # if there is at least one file, then this is a valid path
                # otherwise, it isn't, and it doesn't exist
                if res:
                    st = os.lstat(self.src + "/" + basename)
                    at = dict((key, getattr(st, key)) for key in (
                        'st_atime', 'st_ctime','st_gid', 'st_mode', 'st_mtime', 'st_nlink', 'st_size','st_uid','st_blocks'
                    ))
                else:
                    raise FuseOSError(errno.ENOENT)

        # if it's a file
        elif os.path.isfile(self.src + "/" + basename):
            # fetch the tags associated with this file in the database
            res = self.cur.execute(f"SELECT tags FROM files WHERE path LIKE '{basename}'").fetchone()
            res_tags = [tag for tag in res[0].split("/") if tag]

            # fetch the tags coming from the path
            tags = path.split("/")[1:-1]

            # if the tags on the requested path is a subset of the tags on the database, then the path is valid
            # otherwise, it is not a valid path, therefore there is no file at the specified location
            if (set(tags) <= set(res_tags)):
                st = os.lstat(self.src + "/" + basename)
                at = dict((key, getattr(st, key)) for key in (
                    'st_atime', 'st_ctime','st_gid', 'st_mode', 'st_mtime', 'st_nlink', 'st_size','st_uid','st_blocks'
                ))
                at['st_mode'] = at['st_mode'] | stat.S_IFLNK  # make every file look as a symlink
            else:
                raise FuseOSError(errno.ENOENT)

        # if it's neither a file nor a folder, then it does not exist
        else:
            raise FuseOSError(errno.ENOENT)

        return at

    def getxattr(self, path, name, position=0):
        """Get the value of an extended attribute for a file or directory.

        Extended attributes are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): The path to the file or directory in the virtual filesystem.
            name (str): The name of the extended attribute to retrieve.
            position (int, optional): Offset within the attribute value (usually 0, rarely used).

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def ioctl(self, path, cmd, arg, fip, flags, data):
        """ Performs a variety of control functions related to streams devices.

        This functionality is not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): The path to the file or directory in the virtual filesystem.
            cmd (int): The ioctl command code.
            arg (int): Additional argument for the ioctl command.
            fip (object): File information pointer (may be None).
            flags (int): Flags for the ioctl operation.
            data (bytes): Optional data for the ioctl operation.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def link(self, target, source):
        """ Creates a hardlink between two paths.

        Hard links are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            `target` (str): Target location for the hardlink in the virtual filesystem.
            `source` (str): File that the hardlink will point to in the virtual filesystem.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def listxattr(self, path):
        """List all extended attribute names for a file or directory.

        Extended attributes are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): The path to a file or directory in the virtual filesystem.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def mknod(self, path, mode, dev):
        """ Creates special files.

        This functionality is not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): The path at which to create the node in the virtual filesystem.
            mode (int): The file type and mode bits (permissions and file type).
            dev (int): Device number (only relevant for device special files).

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def readlink(self, path):
        """ Return the target path of a symlink in the virtual filesystem.

        Args:
            path (str): The path to the symlink in the virtual filesystem.

        Returns:
            str: The path to the corresponding real file in the source directory.
        """

        # split `path` to get the basename
        basename = path.split("/")[-1]

        return self.src + "/" + basename

    def removexattr(self, path, name):
        """Remove an extended attribute from a file or directory.

        Extended attributes are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): The path to the file or directory.
            name (str): The name of the extended attribute to remove.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def rename(self, old, new):
        """ Rename a file or directory in the virtual filesystem.

        Args:
            old (str): The current path to the file or directory in the virtual filesystem.
            new (str): The new path for the file or directory in the virtual filesystem.
        """

        # TODO

        raise FuseOSError(errno.ENOSYS)

    def setxattr(self, path, name, value, options, position=0):
        """Set the value of an extended attribute for a file or directory.

        Extended attributes are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): The path to the file or directory.
            name (str): The name of the extended attribute to set.
            value (bytes): The value to set for the attribute.
            options (int): Flags indicating how the attribute should be set (e.g., create, replace).
            position (int, optional): Offset within the attribute value (usually 0, rarely used).

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def statfs(self, path):
        """ Get the filesystem statistics.

        Always returns the statistics of the filesystem where the Stag repository is in.

        Args:
            `path` (str): The path to the file or folder.

        Returns:
            dict: A dictionary containing filesystem statistics.
        """

        stv = os.statvfs(self.src)
        return dict(
            (key, getattr(stv, key)) for key in (
                'f_bavail', 'f_bfree', 'f_blocks', 'f_bsize',  'f_favail',
                'f_ffree',  'f_files', 'f_flag',   'f_frsize', 'f_namemax'
            )
        )

    def symlink(self, name, target):
        """ Creates a symlink in the virtual filesystem, used to add tag to file.

        Args:
            `name` (str): The path of the symlink.
            `target` (str): The path which the symlink will point to.
        """

        # TODO

        raise FuseOSError(errno.ENOSYS)

    def unlink(self, path):
        """ Removes a file in the virtual filesystem.

        Args:
            `path` (str): The path to the file to remove.
        """

        # TODO

        raise FuseOSError(errno.ENOSYS)

    def utimens(self, path, times=None):
        """ Sets the access and modified times of a file or folder.

        Args:
            path (str): The path to a file or folder in the virtual filesystem.
            times: If times is not `None`, it must be a 2-tuple of the form (atime, mtime) where each member is an int or float expressing seconds.

        Raises:
            FuseOSError: If the path does not exist (errno.ENOENT).
        """

        is_root, is_file, is_tag, is_valid = get_info(path, check_valid=True)

        if is_valid:
            os.utime(path, times=times)
        else:
            raise FuseOSError(errno.ENOENT)

        pass

    # ---------------------------------------------------------------------------------------------------------------
    # Folder methods
    # ---------------------------------------------------------------------------------------------------------------

    def fsyncdir(self, path, datasync, fh):
        """ Synchronize directory contents.

         Args:
            path (str): The path to the directory in the virtual filesystem.
            datasync (bool): If True, only synchronize user data, not metadata.
            fh (int): File handle for the directory.

        Returns:
            int: Always returns 0.
        """

        return 0

    def mkdir(self, path, mode):
        """ Creates a directory in the virtual filesystem.

        Since tags are folders in the real filesystem, all this function does is create a directory in the real filesystem.

        Args:
            path (str): The path to create a new folder.

        Raises:
            Whatever os.mkdir() might raise.
        """

        # split `path` to get the basename
        basename = path.split("/")[-1]

        # create directory at `basename`
        os.mkdir(f"{self.src}/{basename}")

        return

    def opendir(self, path):
        """Open a directory for reading.

        Args:
            path (str): The path to the directory in the virtual filesystem.

        Returns:
            int: Always returns 0.
        """

        return 0

    def readdir(self, path, fh):
        """ Reads the content of a directory in the virtual filesystem.

        Args:
            path (str): The path to the directory in the virtual filesystem (assuming its always a folder).
            fh (int): File handle (ignored).

        Yields:
            str: The names of entries in the directory, including files, tags (as subdirectories), and '.' and '..'.
        """

        # split `path` to get the basename
        basename = path.split("/")[-1]

        # contents of the directory
        dirents = ['.', '..']

        # if it's the root directory
        if basename == "":
            dirents.extend(os.listdir(self.src))

        # if it's a tag
        elif os.path.isdir(self.src + "/" + basename):
            # path is always preceeded by a slash
            tags = path.split("/")[1:]

            # make a query where we fetch all files that have the tags present in the variable `tags`
            conditions = []
            for tag in tags:
                conditions.append(f"tags LIKE '%/{tag}/%'")
            query = "SELECT path, tags FROM files WHERE " + " AND ".join(conditions)

            res = self.cur.execute(query).fetchall()

            # go over all results, append all the files and return unique tags
            for line in res:
                file, ctag = line

                dirents.append(file)
                for tag in [i for i in ctag.split("/") if i]:
                    # NOTE: if the nÂº of files get large the following for loop is inefficient
                    # instead of writing `tag not in dirents` maybe have an auxiliary var to hold already printed tags
                    if tag not in tags and tag not in dirents:
                        dirents.append(tag)

        for r in dirents:
            yield r

    def releasedir(self, path, fh):
        """Release resources associated with an open directory.

        Args:
            path (str): The path to the directory in the virtual filesystem.
            fh (int): File handle for the directory.

        Returns:
            int: Always returns 0.
        """

        return 0

    def rmdir(self, path):
        """ Deletes a folder in the virtual filesystem.

        Args:
            `path` (str): The location of the folder to remove (assuming its always a folder).

        Raises:
            FuseOSError: errno.ENOENT if it doesn't point to a valid path.
        """

        # get basename
        basename = path.split("/")[-1]

        # check whether `path` points to a valid combination of folders
        tags = path.split("/")[1:]

        if len(tags) > 1:
            conditions = []
            for tag in tags:
                conditions.append(f"tags LIKE '%/{tag}/%'")
            query = "SELECT path, tags FROM files WHERE " + " AND ".join(conditions)

            res = self.cur.execute(query).fetchone()

            if not res:
                raise FuseOSError(errno.ENOENT)

        # remove directory
        os.rmdir(f"{self.src}/{basename}")

        # remove tags from files
        for tag in tags:
            self.cur.execute(f"UPDATE files SET tags = REPLACE(tags, '/{tag}/', '')")
        self.con.commit()

        return

    # ---------------------------------------------------------------------------------------------------------------
    # File methods
    # ---------------------------------------------------------------------------------------------------------------

    def create(self, path, mode, fi=None):
        """ Create a file in the virtual filesystem.

        Args:
            path (str): Path to the file in the virtual filesystem.
            mode (int): The permissions mode to set on the new file.
            fi (object, optional): File info object (may be None).
        """

        # TODO

        raise FuseOSError(errno.ENOSYS)

    def flush(self, path, fh):
        """ Flush any cached information for the specified file.

        File methods except for create are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            fh (int): File handle.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def fsync(self, path, fdatasync, fh):
        """ Synchronize file contents and metadata to disk.

        File methods except for create are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            fdatasync (bool): If True, only synchronize user data, not metadata.
            fh (int): File handle.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def open(self, path, flags):
        """ Open a file for reading or writing.

        File methods except for create are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            flags (int): Flags indicating access mode and options.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def read(self, path, length, offset, fh):
        """ Read data from an open file.

        File methods except for create are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            length (int): Number of bytes to read.
            offset (int): Offset in the file to start reading from.
            fh (int): File handle.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def release(self, path, fh):
        """ Release an open file (close it).

        File methods except for create are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            fh (int): File handle.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def truncate(self, path, length, fh=None):
        """ Resize a file to a specified length.

        File methods except for create are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            length (int): The new size of the file in bytes.
            fh (int, optional): File handle (may be None).

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def write(self, path, buf, offset, fh):
        """ Write data to an open file.

        File methods except for create are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            buf (bytes): Data to write.
            offset (int): Offset in the file to start writing at.
            fh (int): File handle.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)


@click.command()
@click.option(     "-i", "--init",  type=click.STRING, nargs=1, metavar="<PATH>",      help="Initialize a Stag repository")
@click.option(     "-m", "--mount", type=click.STRING, nargs=2, metavar="<SRC> <MNT>", help="Mount a Stag repository")
@click.option(     "-d", "--debug", is_flag=True,                                      help="Enable debug logging")
@click.help_option("-h", "--help",                                                     help="Show help dialog")
def main(init, mount, debug):
    if init and mount:
        raise click.UsageError('Cannot use -i, --init and -m, --mount together')

    # set logging level
    logging.getLogger().setLevel(logging.WARNING)  # default logging level
    if debug:
        logging.getLogger().setLevel(logging.INFO)

    # initialize a Stag repository
    if init:
        init = os.path.abspath(init)

        # check if `init` exists
        if not os.path.isdir(init):
            raise Exception(f"folder {init} does not exist")

        # check if `init` is empty
        if os.listdir(init):
            raise Exception(f"folder {init} is not empty")

        # initialize the database
        con = sqlite3.connect(f"{init}/stag.sql")
        cur = con.cursor()
        cur.execute("CREATE TABLE files(path, tags)")
        cur.execute("CREATE TABLE tags(tags)")
        con.commit()
        con.close()

        # create folder for files
        os.popen(f"mkdir {init}/files")

        # print success message
        print(f"Empty Stag repository initialized in {init}")

    # mount a Stag repository
    if mount:
        src, mnt = mount
        src = os.path.abspath(src)
        mnt = os.path.abspath(mnt)

        files = f"{src}/files"
        db    = f"{src}/stag.sql"

        # check if `src` is a Stag repository
        if not os.path.isfile(db):
            raise Exception(f"database file not found in {db}")

        # check if `mnt` exists
        if not os.path.isdir(mnt):
            raise Exception(f"folder {mnt} does not exist")

        # check if `mnt` is empty
        if os.listdir(mnt):
            raise Exception(f"folder {mnt} is not empty")

        # mount the filesystem
        FUSE(StagFS(files,db), mnt, nothreads=True, foreground=True)

    return 0


if __name__ == '__main__':
    main()
