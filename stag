#!/usr/bin/env python3

from fuse import FUSE, FuseOSError, Operations
import sqlite3
import click
import errno
import stat
import sys
import os


class StagFS(Operations):
    # ---------------------------------------------------------------------------------------------------------------
    # Initialization and destruction
    # ---------------------------------------------------------------------------------------------------------------

    def __init__(self, src, db):
        """Called on object initialization.

        Args:
            src (str): Path to the directory containing the real files.
            db (str): Path to the SQLite database file.
        """

        self.src = src
        self.con = sqlite3.connect(db)
        self.cur = self.con.cursor()

    def __del__(self):
        """Called on object destruction.
        """

        self.con.close()

        pass

    def init(self, path):
        """Called on filesystem initialization.

        This function must be used instead of `__init__` if you start threads on initialization.

        Args:
            path (str): Is always `"/"`.
        """

        pass

    def destroy(self, path):
        """Called on filesystem destruction.

        Args:
            path (str): Is always `"/"`.
        """

        pass

    # ---------------------------------------------------------------------------------------------------------------
    # Filesystem methods
    # ---------------------------------------------------------------------------------------------------------------

    def access(self, path, mode):
        """ Determines the accessibility of a file or folder.

        According to the manpage of the function `access`, the usage of this function is discouraged and may be formally deprecated in the future.

        Args:
            `path` (str): The path to the file or folder in the virtual filesystem.
            `mode` (int): The mode to check if the `path` is accesible.
        """

        raise FuseOSError(errno.ENOSYS)

    def chmod(self, path, mode):
        """ Changes the permissions of a given path.

        Args:
            `path` (str): The path to the file or folder.
            `mode` (int): The numeric value of the permissions.
        """

        raise FuseOSError(errno.ENOSYS)

    def chown(self, path, uid, gid):
        """ Changes the owner of a given path.

        Args:
            `path` (str): The path to the file or folder.
            `uid` (int): User ID.
            `gid` (int): Group ID
        """

        raise FuseOSError(errno.ENOSYS)

    def getattr(self, path, fh=None):
        """ Fetches the attributes of a file or folder in the virtual filesystem.

        Args:
            path (str): The path to the file or folder in the virtual filesystem.
            fh (int, optional): File handle (ignored). Defaults to None.

        Returns:
            dict: A dictionary with the attributes of the specified path, similar to the output of os.lstat().

        Raises:
            FuseOSError: If the path does not exist (errno.ENOENT).
        """

        # split `path` to get the basename
        basename = path.split("/")[-1]

        # if `path` is an empty string, it corresponds to the root directory of the mount dir
        # if this is the case, we fetch the attributes of the source dir
        if basename == "":
            st = os.lstat(self.src)
            at = dict((key, getattr(st, key)) for key in (
                'st_atime', 'st_ctime','st_gid', 'st_mode', 'st_mtime', 'st_nlink', 'st_size','st_uid','st_blocks'
            ))

        # if it's a tag
        # we need to check if `path` is valid, and this implies thatthere is at least one file with these tags
        elif os.path.isdir(self.src + "/" + basename):
            tags = path.split("/")[1:]

            # if there is only on tag in `tags`, its itself, and we can just check directly whether the folder exists
            if len(tags) == 1:
                try:
                    st = os.lstat(f"{self.src}/{basename}")
                    at = dict((key, getattr(st, key)) for key in (
                        'st_atime', 'st_ctime','st_gid', 'st_mode', 'st_mtime', 'st_nlink', 'st_size','st_uid','st_blocks'
                    ))
                except FileNotFoundError:
                    raise FuseOSError(errno.ENOENT)
                except Exception:
                    raise FuseOSError(errno.EINVAL)

            else:
                conditions = []
                for tag in tags:
                    conditions.append(f"tags LIKE '%/{tag}/%'")
                query = "SELECT path, tags FROM files WHERE " + " AND ".join(conditions)

                res = self.cur.execute(query).fetchone()

                # if there is at least one file, then this is a valid path
                # otherwise, it isn't, and it doesn't exist
                if res:
                    st = os.lstat(self.src + "/" + basename)
                    at = dict((key, getattr(st, key)) for key in (
                        'st_atime', 'st_ctime','st_gid', 'st_mode', 'st_mtime', 'st_nlink', 'st_size','st_uid','st_blocks'
                    ))
                else:
                    raise FuseOSError(errno.ENOENT)

        # if it's a file
        elif os.path.isfile(self.src + "/" + basename):
            # fetch the tags associated with this file in the database
            res = self.cur.execute(f"SELECT tags FROM files WHERE path LIKE '{basename}'").fetchone()
            res_tags = [tag for tag in res[0].split("/") if tag]

            # fetch the tags coming from the path
            tags = path.split("/")[1:-1]

            # if the tags on the requested path is a subset of the tags on the database, then the path is valid
            # otherwise, it is not a valid path, therefore there is no file at the specified location
            if (set(tags) <= set(res_tags)):
                st = os.lstat(self.src + "/" + basename)
                at = dict((key, getattr(st, key)) for key in (
                    'st_atime', 'st_ctime','st_gid', 'st_mode', 'st_mtime', 'st_nlink', 'st_size','st_uid','st_blocks'
                ))
                at['st_mode'] = at['st_mode'] | stat.S_IFLNK  # make every file look as a symlink
            else:
                raise FuseOSError(errno.ENOENT)

        # if it's neither a file nor a folder, then it does not exist
        else:
            raise FuseOSError(errno.ENOENT)

        return at

    def getxattr(self, path, name, position=0):
        """Get the value of an extended attribute for a file or directory.

        Extended attributes are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): The path to the file or directory in the virtual filesystem.
            name (str): The name of the extended attribute to retrieve.
            position (int, optional): Offset within the attribute value (usually 0, rarely used).

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def ioctl(self, path, cmd, arg, fip, flags, data):
        """ Performs a variety of control functions related to streams devices.

        This functionality is not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): The path to the file or directory in the virtual filesystem.
            cmd (int): The ioctl command code.
            arg (int): Additional argument for the ioctl command.
            fip (object): File information pointer (may be None).
            flags (int): Flags for the ioctl operation.
            data (bytes): Optional data for the ioctl operation.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def link(self, target, source):
        """ Creates a hardlink between two paths.

        Symlinks are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            `target` (str): Target location for the hardlink in the virtual filesystem.
            `source` (str): File that the hardlink will point to in the virtual filesystem.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def listxattr(self, path):
        """List all extended attribute names for a file or directory.

        Extended attributes are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): The path to a file or directory in the virtual filesystem.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def mknod(self, path, mode, dev):
        """ Creates special files.

        This functionality is not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): The path at which to create the node in the virtual filesystem.
            mode (int): The file type and mode bits (permissions and file type).
            dev (int): Device number (only relevant for device special files).

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def readlink(self, path):
        """ Return the target path of a symlink in the virtual filesystem.

        Args:
            path (str): The path to the symlink in the virtual filesystem.

        Returns:
            str: The path to the corresponding real file in the source directory.
        """

        # split `path` to get the basename
        basename = path.split("/")[-1]

        return self.src + "/" + basename

    def removexattr(self, path, name):
        """Remove an extended attribute from a file or directory.

        Extended attributes are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): The path to the file or directory.
            name (str): The name of the extended attribute to remove.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def rename(self, old, new):
        """ Moves (or, in particular, renames) a file or folder.

        Args:
            `old` (str): The path to the file or directory.
            `new` (str): The new path to the file or directory.
        """

        raise FuseOSError(errno.ENOSYS)

    def setxattr(self, path, name, value, options, position=0):
        """Set the value of an extended attribute for a file or directory.

        Extended attributes are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): The path to the file or directory.
            name (str): The name of the extended attribute to set.
            value (bytes): The value to set for the attribute.
            options (int): Flags indicating how the attribute should be set (e.g., create, replace).
            position (int, optional): Offset within the attribute value (usually 0, rarely used).

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def statfs(self, path):
        """ Get the filesystem statistics.

        Always returns the statistics of the filesystem where the Stag repository is in.

        Args:
            `path` (str): The path to the file or folder.

        Returns:
            dict: A dictionary containing filesystem statistics.
        """

        stv = os.statvfs(self.src)
        return dict(
            (key, getattr(stv, key)) for key in (
                'f_bavail', 'f_bfree', 'f_blocks', 'f_bsize',  'f_favail',
                'f_ffree',  'f_files', 'f_flag',   'f_frsize', 'f_namemax'
            )
        )

    def symlink(self, name, target):
        """ Creates a symlink.

        Symlinks are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            `name` (str): The path of the symlink.
            `target` (str): The path which the symlink will point to.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def unlink(self, path):
        """ Deletes a file.

        Args:
            `path` (str): The path to the file to remove.
        """

        raise FuseOSError(errno.ENOSYS)

    def utimens(self, path, times=None):
        """ Sets the access and modified times of a file or folder.

        Args:
            `path` (str): The path to a file or folder in the virtual filesystem.
            `times`: If times is not `None`, it must be a 2-tuple of the form `(atime, mtime)` where each member is an int or float expressing seconds.
        """

        raise FuseOSError(errno.ENOSYS)

    # ---------------------------------------------------------------------------------------------------------------
    # Folder methods
    # ---------------------------------------------------------------------------------------------------------------

    def fsyncdir(self, path, datasync, fh):
        """ Synchronize directory contents.

         Args:
            path (str): The path to the directory in the virtual filesystem.
            datasync (bool): If True, only synchronize user data, not metadata.
            fh (int): File handle for the directory.

        Returns:
            int: Always returns 0.
        """

        return 0

    def mkdir(self, path, mode):
        """ Creates a directory in the virtual filesystem.

        Since tags are folders in the real filesystem, all this function does is create a directory in the real filesystem.

        Args:
            path (str): The path to create a new folder.

        Raises:
            Whatever os.mkdir() might raise.
        """

        # split `path` to get the basename
        basename = path.split("/")[-1]

        # create directory at `basename`
        os.mkdir(f"{self.src}/{basename}")

        return

    def opendir(self, path):
        """Open a directory for reading.

        Args:
            path (str): The path to the directory in the virtual filesystem.

        Returns:
            int: Always returns 0.
        """

        return 0

    def readdir(self, path, fh):
        """ Reads the content of a directory in the virtual filesystem.

        Args:
            path (str): The path to the directory in the virtual filesystem.
            fh (int): File handle (ignored).

        Yields:
            str: The names of entries in the directory, including files, tags (as subdirectories), and '.' and '..'.
        """

        # split `path` to get the basename
        basename = path.split("/")[-1]

        # contents of the directory
        dirents = ['.', '..']

        # if it's the root directory
        if basename == "":
            dirents.extend(os.listdir(self.src))

        # if it's a tag
        elif os.path.isdir(self.src + "/" + basename):
            # path is always preceeded by a slash
            tags = path.split("/")[1:]

            # make a query where we fetch all files that have the tags present in the variable `tags`
            conditions = []
            for tag in tags:
                conditions.append(f"tags LIKE '%/{tag}/%'")
            query = "SELECT path, tags FROM files WHERE " + " AND ".join(conditions)

            res = self.cur.execute(query).fetchall()

            # go over all results, append all the files and return unique tags
            for line in res:
                file, ctag = line

                dirents.append(file)
                for tag in [i for i in ctag.split("/") if i]:
                    # NOTE: if the nÂº of files get large the following for loop is inefficient
                    # instead of writing `tag not in dirents` maybe have an auxiliary var to hold already printed tags
                    if tag not in tags and tag not in dirents:
                        dirents.append(tag)

        for r in dirents:
            yield r

    def releasedir(self, path, fh):
        """Release resources associated with an open directory.

        Args:
            path (str): The path to the directory in the virtual filesystem.
            fh (int): File handle for the directory.

        Returns:
            int: Always returns 0.
        """

        return 0

    def rmdir(self, path):
        """ Deletes a folder.

        Args:
            `path` (str): The location of the folder to remove.
        """

        raise FuseOSError(errno.ENOSYS)

    # ---------------------------------------------------------------------------------------------------------------
    # File methods
    # ---------------------------------------------------------------------------------------------------------------

    def create(self, path, mode, fi=None):
        """Create a new file in the virtual filesystem.

        File methods are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            mode (int): The permissions mode to set on the new file.
            fi (object, optional): File info object (may be None).

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def flush(self, path, fh):
        """Flush any cached information for the specified file.

        File methods are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            fh (int): File handle.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def fsync(self, path, fdatasync, fh):
        """Synchronize file contents and metadata to disk.

        File methods are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            fdatasync (bool): If True, only synchronize user data, not metadata.
            fh (int): File handle.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def open(self, path, flags):
        """Open a file for reading or writing.

        File methods are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            flags (int): Flags indicating access mode and options.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def read(self, path, length, offset, fh):
        """Read data from an open file.

        File methods are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            length (int): Number of bytes to read.
            offset (int): Offset in the file to start reading from.
            fh (int): File handle.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def release(self, path, fh):
        """Release an open file (close it).

        File methods are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            fh (int): File handle.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def truncate(self, path, length, fh=None):
        """Resize a file to a specified length.

        File methods are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            length (int): The new size of the file in bytes.
            fh (int, optional): File handle (may be None).

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)

    def write(self, path, buf, offset, fh):
        """Write data to an open file.

        File methods are not supported in this filesystem and this function will always raise FuseOSError.

        Args:
            path (str): Path to the file in the virtual filesystem.
            buf (bytes): Data to write.
            offset (int): Offset in the file to start writing at.
            fh (int): File handle.

        Raises:
            FuseOSError: Always raised with errno.ENOSYS.
        """

        raise FuseOSError(errno.ENOSYS)


@click.command()
@click.option(     "-i", "--init",  type=click.STRING, nargs=1, metavar="<PATH>",      help="Initialize a Stag repository")
@click.option(     "-m", "--mount", type=click.STRING, nargs=2, metavar="<SRC> <MNT>", help="Mount a Stag repository")
@click.help_option("-h", "--help",                                                     help="Show help dialog")
def main(init, mount):
    if init and mount:
        raise click.UsageError('Cannot use -i, --init and -m, --mount together')

    # initialize a Stag repository
    if init:
        init = os.path.abspath(init)

        # check if `init` exists
        if not os.path.isdir(init):
            raise Exception(f"folder {init} does not exist")

        # check if `init` is empty
        if os.listdir(init):
            raise Exception(f"folder {init} is not empty")

        # initialize the database
        con = sqlite3.connect(f"{init}/stag.sql")
        cur = con.cursor()
        cur.execute("CREATE TABLE files(path, tags)")
        cur.execute("CREATE TABLE tags(tags)")
        con.commit()
        con.close()

        # create folder for files
        os.popen(f"mkdir {init}/files")

        # print success message
        print(f"Empty Stag repository initialized in {init}")

    # mount a Stag repository
    if mount:
        src, mnt = mount
        src = os.path.abspath(src)
        mnt = os.path.abspath(mnt)

        files = f"{src}/files"
        db    = f"{src}/stag.sql"

        # check if `src` is a Stag repository
        if not os.path.isfile(db):
            raise Exception(f"database file not found in {db}")

        # check if `mnt` exists
        if not os.path.isdir(mnt):
            raise Exception(f"folder {mnt} does not exist")

        # check if `mnt` is empty
        if os.listdir(mnt):
            raise Exception(f"folder {mnt} is not empty")

        # mount the filesystem
        FUSE(StagFS(files,db), mnt, nothreads=True, foreground=True)

    return 0


if __name__ == '__main__':
    main()
